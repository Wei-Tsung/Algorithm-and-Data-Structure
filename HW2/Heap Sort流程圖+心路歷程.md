 

Heap Sorting概念的實作首先會使用到堆積二元樹的概念 : 
- 也就是父節點的每一個左邊的子節點為index : 2n，
- 右邊的子節點為index : 2n+1

為了進行這些index乘除法上面的方便，把Array[0]的第一個Element設為0，

這只是進行虛擬化的過程，實質上這一個element並不存在於data裡，之後也不會使用到，只是為了index上方便運算而已



- 此class主要分為兩個函數部分 : 一個為heap_sort，另外一個則為add_heap
- add_heap函數的section主要是用來由下而上重建整個Tree的過程

- heap_sort函數則主要是用來進行排序和交換過程，原則上程式核心的部分主要是在add_heap的部分

- 這次排序主要是想要從小排到大，所以用最小堆積樹，樹根節點為最小值

- （新補充）依據新的規定重新補入class的架構

---

先設定size = len(arr)，設定一個迴圈index由list的最後面一個父節點開始往回推回來直到[,index=1]才停止，
因為0是虛擬變數 ;

進入到堆積樹add_heap函數之後size的意義已經不只是size了，而是做為比較時的index使用，<br>
為了稍晚避免誤踩地雷index out of range(已經踩了很多次地雷)<br>

所以在引入add_heap之前size就先減1再說 ;

int(size/2)開始表示最後一個父節點開始迭代，把每一次迭代屬於父節點的那個值設定為temp = data[i]

堆積樹的性質便是父節點要小於左和右的節點，不過若數值要交換來交換去的實在很沒有效率<br>
所以直接先比較兩個子節點確定哪一個值比較小，再將那一個節點的值與該父節點相比較<br>
如果父節點比較小，表示沒有交換的必要了，將tag=1當作信號，表示這一層的迭代已經結束了，可以換到更上一層<br>

但是如果子節點比較小的話，就和父節點交換數值，<strong>但是這裡是要特別注意的地方，就是當交換發生的時候，<br>
這個節點以下的所有樹大小的次序就已經全被破壞掉了;<br>
 
所以有必要在一直往下一層做同樣模式的比較，直到tag=1或是已經到達最底部才終止</strong>

---

若堆積樹函數已經成功測試完成之後
就要建立heap_sort函數，
這一部分就比較容易些了，因為主要也只是每一次樹建立完成把樹根的值，當作下一個已經排序完成的值而已；

不過值得注意的是一開始我是想要直接將樹的樹根值直接取出，然後在每一次取出後再循環重新建立size-1的新的樹就行了<br>

後來卻發現執行結果全部錯了．．．這種方式似乎並不可行；<br>

因為若直接拿掉樹根，整個樹的結構大小次序又全被打亂了;

解決之道便是將樹根的值與尚未排序好的樹的最後一個子節點交換(已經排序好的點就已經不會再出現在新的重建樹裡面)
因為樹的index最後一個值不可能同時還是其他節點的父節點，所以若替換掉也不會破壞掉堆積樹的結構，
就這樣不斷迭代，每次排序，交換位置之後，size就-1，<br>不再將那個排序好的節點納入下一次的迭代當中直到index=1迭代完成


因為最後要的是從小排到大，所以讀取的時候就把array從最後面讀回來到index=1，就是正確的答案了，<br>
index=[0]不使用

---

參考資料： 

- 圖說演算法  博碩出版 
- 資料結構使用python 蔡明志

> 閱讀資料僅止於了解Sorting本身的原理為何，實際的程式碼內容撰寫為原創

> 可以參考查閱原書籍，兩者的相似度極低


